USE PES 

CREATE TABLE SnehaReportDefinitions (
    ReportId INT PRIMARY KEY IDENTITY(1,1),
    ReportName NVARCHAR(100) NOT NULL,
    Description NVARCHAR(500),
    Category NVARCHAR(50),
    DataSourceType NVARCHAR(50) NOT NULL,
    DataSourceValue NVARCHAR(MAX) NOT NULL, 
    Parameters NVARCHAR(MAX),
    LayoutSettings NVARCHAR(MAX), -- TBA
    AccessRoles NVARCHAR(MAX),
    IsActive BIT DEFAULT 1,
    CreatedDate DATETIME DEFAULT GETDATE(),
    ModifiedDate DATETIME DEFAULT GETDATE()
);

CREATE TABLE SnehaReportParameters (
    ParameterId INT PRIMARY KEY IDENTITY(1,1),
    ReportId INT FOREIGN KEY REFERENCES SnehaReportDefinitions(ReportId),
    ParameterName NVARCHAR(50) NOT NULL,
    DisplayName NVARCHAR(100) NOT NULL,
    ParameterType NVARCHAR(50) NOT NULL, 
    DefaultValue NVARCHAR(MAX),
    IsRequired BIT DEFAULT 0,
    ValidationRule NVARCHAR(500),
    DropdownOptions NVARCHAR(MAX) 
);
SELECT * FROM SnehaReportDefinitions;
SELECT * FROM SnehaReportParameters;


INSERT INTO SnehaReportParameters(ReportId,ParameterName,DisplayName,ParameterType,DefaultValue,IsRequired,ValidationRule,DropdownOptions)VALUES (
5,'PlanAlertID','Enter Plan Alert Id','Textbox',NULL,1,NULL,NULL);


using Custom_report.Models;
using Custom_report.Services;
using Microsoft.AspNetCore.Mvc;
using System.Data;
using System.ComponentModel.DataAnnotations;

namespace Custom_report.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ReportsController : ControllerBase
    {
        private readonly IReportService _reportService;
        private readonly ILogger<ReportsController> _logger;
        
        public ReportsController(IReportService reportService, ILogger<ReportsController> logger)
        {
            _reportService = reportService;
            _logger = logger;
        }
        
        /// <summary>
        /// Get all available reports for the current user
        /// </summary>
        [HttpGet]
        public async Task<ActionResult<ApiResponse<List<ReportDefinition>>>> GetAvailableReports()
        {
            try
            {
                // For now, we'll use default roles. In real app, get from JWT token or session
                var userRoles = new[] { "Admin", "HR", "Sales" };
                
                var reports = await _reportService.GetAvailableReportsAsync(userRoles);
                return Ok(ApiResponse<List<ReportDefinition>>.SuccessResult(reports));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving available reports");
                return StatusCode(500, ApiResponse<List<ReportDefinition>>.ErrorResult("Internal server error"));
            }
        }
        
        /// <summary>
        /// Get report definition by ID
        /// </summary>
        [HttpGet("{id}")]
        public async Task<ActionResult<ApiResponse<ReportDefinition>>> GetReportDefinition(int id)
        {
            try
            {
                var report = await _reportService.GetReportDefinitionAsync(id);
                if (report == null)
                    return NotFound(ApiResponse<ReportDefinition>.ErrorResult("Report not found"));
                
                return Ok(ApiResponse<ReportDefinition>.SuccessResult(report));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving report definition for ID: {ReportId}", id);
                return StatusCode(500, ApiResponse<ReportDefinition>.ErrorResult("Internal server error"));
            }
        }
        
        
        [HttpPost("{id}/generate")]
        public async Task<ActionResult<ApiResponse<object>>> GenerateReport(int id, [FromBody] ReportGenerationRequest request)
        {
            try
            {
                _logger.LogInformation("Generating report {ReportId} with parameters: {@Parameters}", id, request?.Parameters);

                // Handle null request
                var parameters = request?.Parameters ?? new Dictionary<string, object>();
                
                var reportData = await _reportService.GenerateReportAsync(id, parameters);
                
                if (reportData.HasError)
                {
                    _logger.LogWarning("Report generation failed for ID {ReportId}: {Error}", id, reportData.Error);
                    return BadRequest(ApiResponse<object>.ErrorResult(reportData.Error));
                }
                
                // Convert DataTable to a more JSON-friendly format
                var result = new
                {
                    Metadata = reportData.Metadata,
                    Columns = reportData.Data.Columns.Cast<DataColumn>().Select(c => new { 
                        Name = c.ColumnName, 
                        Type = c.DataType.Name 
                    }),
                    Rows = reportData.Data.AsEnumerable().Select(row => 
                        reportData.Data.Columns.Cast<DataColumn>().ToDictionary(
                            col => col.ColumnName, 
                            col => row[col] == DBNull.Value ? null : row[col]
                        )
                    )
                };
                
                _logger.LogInformation("Successfully generated report {ReportId} with {RowCount} rows", id, reportData.Data.Rows.Count);
                return Ok(ApiResponse<object>.SuccessResult(result));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating report for ID: {ReportId}", id);
                return StatusCode(500, ApiResponse<object>.ErrorResult($"Internal server error: {ex.Message}"));
            }
        }
        
        /// <summary>
        /// Create a new report
        /// </summary>
        [HttpPost]
        public async Task<ActionResult<ApiResponse<int>>> CreateReport([FromBody] ReportDefinition report)
        {
            try
            {
                if (!ModelState.IsValid)
                    return BadRequest(ApiResponse<int>.ErrorResult("Invalid model", ModelState.Values.SelectMany(v => v.Errors.Select(e => e.ErrorMessage)).ToList()));
                
                var reportId = await _reportService.CreateReportAsync(report);
                return CreatedAtAction(nameof(GetReportDefinition), new { id = reportId }, ApiResponse<int>.SuccessResult(reportId, "Report created successfully"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating report: {ReportName}", report.ReportName);
                return StatusCode(500, ApiResponse<int>.ErrorResult("Internal server error"));
            }
        }
        
        /// <summary>
        /// Update an existing report
        /// </summary>
        [HttpPut("{id}")]
        public async Task<ActionResult<ApiResponse<bool>>> UpdateReport(int id, [FromBody] ReportDefinition report)
        {
            try
            {
                if (id != report.ReportId)
                    return BadRequest(ApiResponse<bool>.ErrorResult("Report ID mismatch"));
                
                if (!ModelState.IsValid)
                    return BadRequest(ApiResponse<bool>.ErrorResult("Invalid model", ModelState.Values.SelectMany(v => v.Errors.Select(e => e.ErrorMessage)).ToList()));
                
                var success = await _reportService.UpdateReportAsync(report);
                if (!success)
                    return NotFound(ApiResponse<bool>.ErrorResult("Report not found"));
                
                return Ok(ApiResponse<bool>.SuccessResult(true, "Report updated successfully"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating report: {ReportId}", id);
                return StatusCode(500, ApiResponse<bool>.ErrorResult("Internal server error"));
            }
        }
        
        /// <summary>
        /// Delete a report (soft delete)
        /// </summary>
        [HttpDelete("{id}")]
        public async Task<ActionResult<ApiResponse<bool>>> DeleteReport(int id)
        {
            try
            {
                var success = await _reportService.DeleteReportAsync(id);
                if (!success)
                    return NotFound(ApiResponse<bool>.ErrorResult("Report not found"));
                
                return Ok(ApiResponse<bool>.SuccessResult(true, "Report deleted successfully"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting report: {ReportId}", id);
                return StatusCode(500, ApiResponse<bool>.ErrorResult("Internal server error"));
            }
        }
    }

    public class ReportGenerationRequest
    {
        public Dictionary<string, object> Parameters { get; set; } = new Dictionary<string, object>();
    }
}
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5118/api';

// Configure axios defaults
axios.defaults.timeout = 30000; // 30 seconds timeout

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for logging
api.interceptors.request.use(
  (config) => {
    console.log('API Request:', {
      method: config.method,
      url: config.url,
      data: config.data,
      params: config.params
    });
    return config;
  },
  (error) => {
    console.error('Request Error:', error);
    return Promise.reject(error);
  }
);

// Add response interceptor for logging and error handling
api.interceptors.response.use(
  (response) => {
    console.log('API Response:', {
      url: response.config.url,
      status: response.status,
      data: response.data
    });
    return response;
  },
  (error) => {
    console.error('Response Error:', {
      url: error.config?.url,
      status: error.response?.status,
      message: error.message,
      data: error.response?.data
    });
    return Promise.reject(error);
  }
);

export const reportService = {
  // Get all available reports
  async getAvailableReports() {
    try {
      const response = await api.get('/reports');
      return response.data;
    } catch (error) {
      console.error('Error fetching reports:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to fetch reports',
        data: []
      };
    }
  },

  // Get report definition by ID
  async getReportDefinition(reportId) {
    try {
      const response = await api.get(`/reports/${reportId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching report definition:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to fetch report definition',
        data: null
      };
    }
  },

  // Generate report with parameters
  async generateReport(reportId, parameters = {}) {
    try {
      console.log('Generating report:', { reportId, parameters });
      
      // Ensure parameters is an object and not null/undefined
      const cleanedParameters = parameters || {};
      
      // Remove any null or undefined values
      const filteredParameters = Object.entries(cleanedParameters).reduce((acc, [key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
          acc[key] = value;
        }
        return acc;
      }, {});

      const requestBody = {
        parameters: filteredParameters
      };

      console.log('Request body:', requestBody);

      const response = await api.post(`/reports/${reportId}/generate`, requestBody);
      return response.data;
    } catch (error) {
      console.error('Error generating report:', error);
      
      // Return a more user-friendly error response
      const errorMessage = error.response?.data?.message || 
                          error.response?.data?.errors?.join(', ') || 
                          error.message || 
                          'An unexpected error occurred';
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Create a new report
  async createReport(reportData) {
    try {
      console.log('Creating report with data:', reportData);
      
      // Validate required fields
      if (!reportData.reportName || !reportData.reportName.trim()) {
        return {
          success: false,
          message: 'Report name is required'
        };
      }
      
      if (!reportData.dataSourceType || !reportData.dataSourceType.trim()) {
        return {
          success: false,
          message: 'Data source type is required'
        };
      }
      
      if (!reportData.dataSourceValue || !reportData.dataSourceValue.trim()) {
        return {
          success: false,
          message: 'Data source value is required'
        };
      }

      const response = await api.post('/reports', reportData);
      
      // Check if response has the expected structure
      if (response.data) {
        return response.data; // This should contain { success: true, data: reportId }
      }
      
      return {
        success: true,
        message: 'Report created successfully',
        data: response.data
      };
      
    } catch (error) {
      console.error('Error creating report:', error);
      
      // Extract error message from response
      let errorMessage = 'Failed to create report';
      
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.response?.data?.errors?.length > 0) {
        errorMessage = error.response.data.errors.join(', ');
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Update an existing report
  async updateReport(reportId, reportData) {
    try {
      const response = await api.put(`/reports/${reportId}`, reportData);
      return response.data;
    } catch (error) {
      console.error('Error updating report:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to update report',
        data: null
      };
    }
  },

  // Delete a report
  async deleteReport(reportId) {
    try {
      const response = await api.delete(`/reports/${reportId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting report:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to delete report',
        data: null
      };
    }
  },

  // Export report data
  async exportReport(reportId, parameters = {}, format = 'csv') {
    try {
      const response = await api.post(`/reports/${reportId}/export`, {
        parameters,
        format
      }, {
        responseType: 'blob'
      });
      
      return response.data;
    } catch (error) {
      console.error('Error exporting report:', error);
      throw error;
    }
  }
};import React, { useState } from 'react';
import { reportService } from '../services/reportService';
import '../styles/ReportForm.css';

const ReportForm = ({ onBack, onSave }) => {
  const [formData, setFormData] = useState({
    reportName: '',
    description: '',
    category: '',
    dataSourceType: 'SQL',
    dataSourceValue: '',
    accessRoles: '',
    isActive: true
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log('Form submitted with data:', formData);
    
    try {
      setLoading(true);
      setError(null);
      
      // Exactly match your backend working format
      let accessRolesFormatted = '[]';
      if (formData.accessRoles && formData.accessRoles.trim()) {
        const rolesArray = formData.accessRoles
          .split(',')
          .map(role => role.trim())
          .filter(role => role.length > 0);
        accessRolesFormatted = `["${rolesArray.join('","')}"]`;
      }
      
      const reportData = {
        reportName: formData.reportName.trim(),
        description: formData.description?.trim() || null,
        category: formData.category?.trim() ||null,
        dataSourceType: formData.dataSourceType,
        dataSourceValue: formData.dataSourceValue.trim(),
        parameters: "", 
        layoutSettings: "", 
        accessRoles: accessRolesFormatted,
        isActive: formData.isActive
      };
      
      console.log('Final report data being sent:', reportData);
      console.log('AccessRoles formatted as:', accessRolesFormatted);
      
      const response = await reportService.createReport(reportData);
      console.log('Response received:', response);
      
      if (response && response.success) {
        console.log('Report created successfully!');
        setSuccess(true);
        setTimeout(() => {
          onSave();
        }, 2000);
      } else {
        console.error('Report creation failed:', response);
        setError(response?.message || 'Failed to create report');
      }
    } catch (err) {
      console.error('Exception in handleSubmit:', err);
      console.error('Error response:', err.response);
      setError(err.response?.data?.message || err.message || 'Failed to create report');
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="success-message">
        <h2>✅ Report Created Successfully!</h2>
        <p>Redirecting back to reports list...</p>
      </div>
    );
  }

  return (
    <div className="report-form">
      <div className="form-header">
        <button className="btn btn-secondary" onClick={onBack}>
          ← Back to Reports
        </button>
        <h2>Create New Report</h2>
      </div>

      <form onSubmit={handleSubmit} className="form">
        <div className="form-group">
          <label htmlFor="reportName">Report Name *</label>
          <input
            type="text"
            id="reportName"
            name="reportName"
            value={formData.reportName}
            onChange={handleInputChange}
            required
            className="form-input"
            maxLength="100"
          />
        </div>

        <div className="form-group">
          <label htmlFor="description">Description</label>
          <textarea
            id="description"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            rows="3"
            className="form-textarea"
            maxLength="500"
          />
        </div>

        <div className="form-row">
          <div className="form-group">
            <label htmlFor="category">Category</label>
            <input
              type="text"
              id="category"
              name="category"
              value={formData.category}
              onChange={handleInputChange}
              className="form-input"
              maxLength="50"
            />
          </div>

          <div className="form-group">
            <label htmlFor="dataSourceType">Data Source Type *</label>
            <select
              id="dataSourceType"
              name="dataSourceType"
              value={formData.dataSourceType}
              onChange={handleInputChange}
              required
              className="form-select"
            >
              <option value="SQL">SQL Query</option>
              <option value="StoredProcedure">Stored Procedure</option>
              <option value="API">API Endpoint</option>
            </select>
          </div>
        </div>

        <div className="form-group">
          <label htmlFor="dataSourceValue">
            {formData.dataSourceType === 'StoredProcedure' ? 'Procedure Name' : 
             formData.dataSourceType === 'API' ? 'API Endpoint' : 'SQL Query'} *
          </label>
          <textarea
            id="dataSourceValue"
            name="dataSourceValue"
            value={formData.dataSourceValue}
            onChange={handleInputChange}
            required
            rows="4"
            className="form-textarea"
            placeholder={
              formData.dataSourceType === 'StoredProcedure' ? 'GetEmployeeReport' :
              formData.dataSourceType === 'API' ? 'https://api.example.com/data' :
              'SELECT * FROM TableName WHERE Column = @Parameter'
            }
          />
        </div>

        <div className="form-group">
          <label htmlFor="accessRoles">Access Roles (comma separated)</label>
          <input
            type="text"
            id="accessRoles"
            name="accessRoles"
            value={formData.accessRoles}
            onChange={handleInputChange}
            className="form-input"
            placeholder="Admin, HR, Sales"
          />
          <small className="form-help">Enter roles separated by commas (e.g., Admin, HR, Sales)</small>
        </div>

        <div className="form-group">
          <label className="checkbox-label">
            <input
              type="checkbox"
              name="isActive"
              checked={formData.isActive}
              onChange={handleInputChange}
            />
            Active
          </label>
        </div>

        {error && (
          <div className="error-message">
            <strong>Error:</strong> {error}
          </div>
        )}

        <div className="form-actions">
          <button type="button" className="btn btn-secondary" onClick={onBack}>
            Cancel
          </button>
          <button type="submit" className="btn btn-primary" disabled={loading}>
            {loading ? 'Creating...' : 'Create Report'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default ReportForm;
