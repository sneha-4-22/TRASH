import React, { useState } from 'react';
import { reportService } from '../services/reportService';
import '../styles/ReportForm.css';

const ReportForm = ({ onBack, onSave }) => {
  const [formData, setFormData] = useState({
    reportName: '',
    description: '',
    category: '',
    dataSourceType: 'SQL',
    dataSourceValue: '',
    accessRoles: '',
    isActive: true
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log('Form submitted with data:', formData);
    
    try {
      setLoading(true);
      setError(null);
      
      // Exactly match your backend working format
      let accessRolesFormatted = '[]';
      if (formData.accessRoles && formData.accessRoles.trim()) {
        const rolesArray = formData.accessRoles
          .split(',')
          .map(role => role.trim())
          .filter(role => role.length > 0);
        accessRolesFormatted = `["${rolesArray.join('","')}"]`;
      }
      
      const reportData = {
        reportName: formData.reportName.trim(),
        description: formData.description?.trim() || null,
        category: formData.category?.trim() ||null,
        dataSourceType: formData.dataSourceType,
        dataSourceValue: formData.dataSourceValue.trim(),
        parameters: "", 
        layoutSettings: "", 
        accessRoles: accessRolesFormatted,
        isActive: formData.isActive
      };
      
      console.log('Final report data being sent:', reportData);
      console.log('AccessRoles formatted as:', accessRolesFormatted);
      
      const response = await reportService.createReport(reportData);
      console.log('Response received:', response);
      
      if (response && response.success) {
        console.log('Report created successfully!');
        setSuccess(true);
        setTimeout(() => {
          onSave();
        }, 2000);
      } else {
        console.error('Report creation failed:', response);
        setError(response?.message || 'Failed to create report');
      }
    } catch (err) {
      console.error('Exception in handleSubmit:', err);
      console.error('Error response:', err.response);
      setError(err.response?.data?.message || err.message || 'Failed to create report');
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="success-message">
        <h2>✅ Report Created Successfully!</h2>
        <p>Redirecting back to reports list...</p>
      </div>
    );
  }

  return (
    <div className="report-form">
      <div className="form-header">
        <button className="btn btn-secondary" onClick={onBack}>
          ← Back to Reports
        </button>
        <h2>Create New Report</h2>
      </div>

      <form onSubmit={handleSubmit} className="form">
        <div className="form-group">
          <label htmlFor="reportName">Report Name *</label>
          <input
            type="text"
            id="reportName"
            name="reportName"
            value={formData.reportName}
            onChange={handleInputChange}
            required
            className="form-input"
            maxLength="100"
          />
        </div>

        <div className="form-group">
          <label htmlFor="description">Description</label>
          <textarea
            id="description"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            rows="3"
            className="form-textarea"
            maxLength="500"
          />
        </div>

        <div className="form-row">
          <div className="form-group">
            <label htmlFor="category">Category</label>
            <input
              type="text"
              id="category"
              name="category"
              value={formData.category}
              onChange={handleInputChange}
              className="form-input"
              maxLength="50"
            />
          </div>

          <div className="form-group">
            <label htmlFor="dataSourceType">Data Source Type *</label>
            <select
              id="dataSourceType"
              name="dataSourceType"
              value={formData.dataSourceType}
              onChange={handleInputChange}
              required
              className="form-select"
            >
              <option value="SQL">SQL Query</option>
              <option value="StoredProcedure">Stored Procedure</option>
              <option value="API">API Endpoint</option>
            </select>
          </div>
        </div>

        <div className="form-group">
          <label htmlFor="dataSourceValue">
            {formData.dataSourceType === 'StoredProcedure' ? 'Procedure Name' : 
             formData.dataSourceType === 'API' ? 'API Endpoint' : 'SQL Query'} *
          </label>
          <textarea
            id="dataSourceValue"
            name="dataSourceValue"
            value={formData.dataSourceValue}
            onChange={handleInputChange}
            required
            rows="4"
            className="form-textarea"
            placeholder={
              formData.dataSourceType === 'StoredProcedure' ? 'GetEmployeeReport' :
              formData.dataSourceType === 'API' ? 'https://api.example.com/data' :
              'SELECT * FROM TableName WHERE Column = @Parameter'
            }
          />
        </div>

        <div className="form-group">
          <label htmlFor="accessRoles">Access Roles (comma separated)</label>
          <input
            type="text"
            id="accessRoles"
            name="accessRoles"
            value={formData.accessRoles}
            onChange={handleInputChange}
            className="form-input"
            placeholder="Admin, HR, Sales"
          />
          <small className="form-help">Enter roles separated by commas (e.g., Admin, HR, Sales)</small>
        </div>

        <div className="form-group">
          <label className="checkbox-label">
            <input
              type="checkbox"
              name="isActive"
              checked={formData.isActive}
              onChange={handleInputChange}
            />
            Active
          </label>
        </div>

        {error && (
          <div className="error-message">
            <strong>Error:</strong> {error}
          </div>
        )}

        <div className="form-actions">
          <button type="button" className="btn btn-secondary" onClick={onBack}>
            Cancel
          </button>
          <button type="submit" className="btn btn-primary" disabled={loading}>
            {loading ? 'Creating...' : 'Create Report'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default ReportForm;














using Custom_report.Models;
using Dapper;
using System.Data;
using System.Data.SqlClient;
using Newtonsoft.Json;

namespace Custom_report.Services
{
    public interface IReportService
    {
        Task<List<ReportDefinition>> GetAvailableReportsAsync(IEnumerable<string> userRoles);
        Task<ReportDefinition> GetReportDefinitionAsync(int reportId);
        Task<ReportData> GenerateReportAsync(int reportId, Dictionary<string, object> parameters);
        Task<int> CreateReportAsync(ReportDefinition report);
        Task<bool> UpdateReportAsync(ReportDefinition report);
        Task<bool> DeleteReportAsync(int reportId);
    }
    
    public sealed class ReportService : IReportService
    {
        private static ReportService? _instance;
        private static readonly object _lockObject = new object();
        private readonly IDatabaseService _databaseService;
        private readonly ILogger<ReportService> _logger;
        
        private ReportService(IDatabaseService databaseService, ILogger<ReportService> logger)
        {
            _databaseService = databaseService;
            _logger = logger;
        }
        
        public static ReportService GetInstance(IDatabaseService databaseService, ILogger<ReportService> logger)
        {
            if (_instance == null)
            {
                lock (_lockObject)
                {
                    if (_instance == null)
                    {
                        _instance = new ReportService(databaseService, logger);
                    }
                }
            }
            return _instance;
        }
        
        public async Task<List<ReportDefinition>> GetAvailableReportsAsync(IEnumerable<string> userRoles)
        {
            try
            {
                using var connection = _databaseService.GetConnection();
                var sql = @"
                    SELECT ReportId, ReportName, Description, Category, DataSourceType, 
                           DataSourceValue, Parameters, LayoutSettings, AccessRoles, 
                           IsActive, CreatedDate, ModifiedDate 
                    FROM SnehaReportDefinitions 
                    WHERE IsActive = 1";
                
                var reports = (await connection.QueryAsync<ReportDefinition>(sql)).ToList();
                
                // Filter by user roles
                var filteredReports = reports.Where(r =>
                {
                    if (string.IsNullOrEmpty(r.AccessRoles)) return true;
                    
                    try
                    {
                        var accessRoles = JsonConvert.DeserializeObject<List<string>>(r.AccessRoles);
                        return !accessRoles.Any() || accessRoles.Any(role => userRoles.Contains(role));
                    }
                    catch
                    {
                        return true; // If JSON parsing fails, allow access
                    }
                }).ToList();
                
                return filteredReports;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving available reports");
                throw;
            }
        }
        
        public async Task<ReportDefinition> GetReportDefinitionAsync(int reportId)
        {
            try
            {
                using var connection = _databaseService.GetConnection();
                
                var reportSql = @"
                    SELECT ReportId, ReportName, Description, Category, DataSourceType, 
                           DataSourceValue, Parameters, LayoutSettings, AccessRoles, 
                           IsActive, CreatedDate, ModifiedDate 
                    FROM SnehaReportDefinitions 
                    WHERE ReportId = @ReportId";
                
                var report = await connection.QueryFirstOrDefaultAsync<ReportDefinition>(reportSql, new { ReportId = reportId });
                
                if (report == null) return null;
                
                // Load parameters
                var parametersSql = @"
                    SELECT ParameterId, ReportId, ParameterName, DisplayName, ParameterType, 
                           DefaultValue, IsRequired, ValidationRule, DropdownOptions 
                    FROM SnehaReportParameters 
                    WHERE ReportId = @ReportId";
                
                var parameters = (await connection.QueryAsync<ReportParameter>(parametersSql, new { ReportId = reportId })).ToList();
                report.ReportParameters = parameters;
                
                return report;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving report definition for ReportId: {ReportId}", reportId);
                throw;
            }
        }

        public async Task<ReportData> GenerateReportAsync(int reportId, Dictionary<string, object> parameters)
        {
            var result = new ReportData();
            
            try
            {
                var reportDef = await GetReportDefinitionAsync(reportId);
                if (reportDef == null)
                {
                    result.Error = "Report not found";
                    return result;
                }
                
                result.Metadata = reportDef;
                
                // Validate required parameters
                var validationError = ValidateParameters(reportDef.ReportParameters, parameters);
                if (!string.IsNullOrEmpty(validationError))
                {
                    result.Error = validationError;
                    return result;
                }
                
                using var connection = _databaseService.GetConnection();
                
                switch (reportDef.DataSourceType.ToLower())
                {
                    case "storedprocedure":
                        result.Data = await ExecuteStoredProcedureAsync(connection, reportDef.DataSourceValue, parameters);
                        break;
                        
                    case "sql":
                        result.Data = await ExecuteSqlQueryAsync(connection, reportDef.DataSourceValue, parameters);
                        break;
                        
                    default:
                        result.Error = "Unsupported data source type";
                        break;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating report for ReportId: {ReportId}", reportId);
                result.Error = $"An error occurred while generating the report: {ex.Message}";
            }
            
            return result;
        }

        private string ValidateParameters(List<ReportParameter> reportParams, Dictionary<string, object> providedParams)
        {
            if (reportParams == null || !reportParams.Any())
                return null;

            var requiredParams = reportParams.Where(p => p.IsRequired).ToList();
            
            foreach (var requiredParam in requiredParams)
            {
                if (!providedParams.ContainsKey(requiredParam.ParameterName) || 
                    providedParams[requiredParam.ParameterName] == null ||
                    string.IsNullOrWhiteSpace(providedParams[requiredParam.ParameterName].ToString()))
                {
                    return $"Required parameter '{requiredParam.DisplayName}' is missing or empty";
                }
            }

            return null;
        }

        private async Task<DataTable> ExecuteStoredProcedureAsync(IDbConnection connection, string procName, Dictionary<string, object> parameters)
        {
            var dataTable = new DataTable();
            
            try
            {
                if (connection.State != ConnectionState.Open)
                    connection.Open();

                using var command = connection.CreateCommand();
                command.CommandText = procName;
                command.CommandType = CommandType.StoredProcedure;
                command.CommandTimeout = 300; // 5 minutes timeout
                
                foreach (var param in parameters)
                {
                    var dbParam = command.CreateParameter();
                    dbParam.ParameterName = $"@{param.Key}";
                    dbParam.Value = ConvertParameterValue(param.Value);
                    command.Parameters.Add(dbParam);
                }

                using var reader = command.ExecuteReader();
                dataTable.Load(reader);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error executing stored procedure: {ProcName}", procName);
                throw;
            }
            
            return dataTable;
        }

        private async Task<DataTable> ExecuteSqlQueryAsync(IDbConnection connection, string sql, Dictionary<string, object> parameters)
        {
            var dataTable = new DataTable();
            
            try
            {
                if (connection.State != ConnectionState.Open)
                    connection.Open();

                using var command = connection.CreateCommand();
                command.CommandText = sql;
                command.CommandType = CommandType.Text;
                command.CommandTimeout = 300; // 5 minutes timeout
                
                foreach (var param in parameters)
                {
                    var dbParam = command.CreateParameter();
                    dbParam.ParameterName = $"@{param.Key}";
                    dbParam.Value = ConvertParameterValue(param.Value);
                    command.Parameters.Add(dbParam);
                }
                
                using var reader = command.ExecuteReader();
                dataTable.Load(reader);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error executing SQL query: {Sql}", sql);
                throw;
            }
            
            return dataTable;
        }

        private object ConvertParameterValue(object value)
        {
            if (value == null)
                return DBNull.Value;

            var stringValue = value.ToString();
            
            if (string.IsNullOrWhiteSpace(stringValue))
                return DBNull.Value;

            // Try to parse dates
            if (DateTime.TryParse(stringValue, out DateTime dateValue))
            {
                return dateValue;
            }

            // Try to parse numbers
            if (int.TryParse(stringValue, out int intValue))
            {
                return intValue;
            }

            if (decimal.TryParse(stringValue, out decimal decimalValue))
            {
                return decimalValue;
            }

            // Return as string
            return stringValue;
        }
        
        public async Task<int> CreateReportAsync(ReportDefinition report)
        {
            try
            {
                using var connection = _databaseService.GetConnection();
                
                var sql = @"
                    INSERT INTO SnehaReportDefinitions 
                    (ReportName, Description, Category, DataSourceType, DataSourceValue, 
                     Parameters, LayoutSettings, AccessRoles, IsActive, CreatedDate, ModifiedDate)
                    OUTPUT INSERTED.ReportId
                    VALUES 
                    (@ReportName, @Description, @Category, @DataSourceType, @DataSourceValue, 
                     @Parameters, @LayoutSettings, @AccessRoles, @IsActive, GETDATE(), GETDATE())";
                
                var reportId = await connection.QuerySingleAsync<int>(sql, report);
                
                // Insert parameters if any
                if (report.ReportParameters?.Any() == true)
                {
                    var parameterSql = @"
                        INSERT INTO SnehaReportParameters 
                        (ReportId, ParameterName, DisplayName, ParameterType, DefaultValue, 
                         IsRequired, ValidationRule, DropdownOptions)
                        VALUES 
                        (@ReportId, @ParameterName, @DisplayName, @ParameterType, @DefaultValue, 
                         @IsRequired, @ValidationRule, @DropdownOptions)";
                    
                    foreach (var param in report.ReportParameters)
                    {
                        param.ReportId = reportId;
                        await connection.ExecuteAsync(parameterSql, param);
                    }
                }
                
                return reportId;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating report: {ReportName}", report.ReportName);
                throw;
            }
        }
        
        public async Task<bool> UpdateReportAsync(ReportDefinition report)
        {
            try
            {
                using var connection = _databaseService.GetConnection();
                
                var sql = @"
                    UPDATE SnehaReportDefinitions 
                    SET ReportName = @ReportName, Description = @Description, Category = @Category,
                        DataSourceType = @DataSourceType, DataSourceValue = @DataSourceValue,
                        Parameters = @Parameters, LayoutSettings = @LayoutSettings, 
                        AccessRoles = @AccessRoles, IsActive = @IsActive, ModifiedDate = GETDATE()
                    WHERE ReportId = @ReportId";
                
                var rowsAffected = await connection.ExecuteAsync(sql, report);
                return rowsAffected > 0;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating report: {ReportId}", report.ReportId);
                throw;
            }
        }
        
        public async Task<bool> DeleteReportAsync(int reportId)
        {
            try
            {
                using var connection = _databaseService.GetConnection();
                
                // Soft delete
                var sql = @"
                    UPDATE SnehaReportDefinitions 
                    SET IsActive = 0, ModifiedDate = GETDATE()
                    WHERE ReportId = @ReportId";
                
                var rowsAffected = await connection.ExecuteAsync(sql, new { ReportId = reportId });
                return rowsAffected > 0;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting report: {ReportId}", reportId);
                throw;
            }
        }
    }
}


using Custom_report.Models;
using Custom_report.Services;
using Microsoft.AspNetCore.Mvc;
using System.Data;
using System.ComponentModel.DataAnnotations;

namespace Custom_report.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ReportsController : ControllerBase
    {
        private readonly IReportService _reportService;
        private readonly ILogger<ReportsController> _logger;
        
        public ReportsController(IReportService reportService, ILogger<ReportsController> logger)
        {
            _reportService = reportService;
            _logger = logger;
        }
        
        /// <summary>
        /// Get all available reports for the current user
        /// </summary>
        [HttpGet]
        public async Task<ActionResult<ApiResponse<List<ReportDefinition>>>> GetAvailableReports()
        {
            try
            {
                // For now, we'll use default roles. In real app, get from JWT token or session
                var userRoles = new[] { "Admin", "HR", "Sales" };
                
                var reports = await _reportService.GetAvailableReportsAsync(userRoles);
                return Ok(ApiResponse<List<ReportDefinition>>.SuccessResult(reports));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving available reports");
                return StatusCode(500, ApiResponse<List<ReportDefinition>>.ErrorResult("Internal server error"));
            }
        }
        
        /// <summary>
        /// Get report definition by ID
        /// </summary>
        [HttpGet("{id}")]
        public async Task<ActionResult<ApiResponse<ReportDefinition>>> GetReportDefinition(int id)
        {
            try
            {
                var report = await _reportService.GetReportDefinitionAsync(id);
                if (report == null)
                    return NotFound(ApiResponse<ReportDefinition>.ErrorResult("Report not found"));
                
                return Ok(ApiResponse<ReportDefinition>.SuccessResult(report));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving report definition for ID: {ReportId}", id);
                return StatusCode(500, ApiResponse<ReportDefinition>.ErrorResult("Internal server error"));
            }
        }
        
        
        [HttpPost("{id}/generate")]
        public async Task<ActionResult<ApiResponse<object>>> GenerateReport(int id, [FromBody] ReportGenerationRequest request)
        {
            try
            {
                _logger.LogInformation("Generating report {ReportId} with parameters: {@Parameters}", id, request?.Parameters);

                // Handle null request
                var parameters = request?.Parameters ?? new Dictionary<string, object>();
                
                var reportData = await _reportService.GenerateReportAsync(id, parameters);
                
                if (reportData.HasError)
                {
                    _logger.LogWarning("Report generation failed for ID {ReportId}: {Error}", id, reportData.Error);
                    return BadRequest(ApiResponse<object>.ErrorResult(reportData.Error));
                }
                
                // Convert DataTable to a more JSON-friendly format
                var result = new
                {
                    Metadata = reportData.Metadata,
                    Columns = reportData.Data.Columns.Cast<DataColumn>().Select(c => new { 
                        Name = c.ColumnName, 
                        Type = c.DataType.Name 
                    }),
                    Rows = reportData.Data.AsEnumerable().Select(row => 
                        reportData.Data.Columns.Cast<DataColumn>().ToDictionary(
                            col => col.ColumnName, 
                            col => row[col] == DBNull.Value ? null : row[col]
                        )
                    )
                };
                
                _logger.LogInformation("Successfully generated report {ReportId} with {RowCount} rows", id, reportData.Data.Rows.Count);
                return Ok(ApiResponse<object>.SuccessResult(result));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating report for ID: {ReportId}", id);
                return StatusCode(500, ApiResponse<object>.ErrorResult($"Internal server error: {ex.Message}"));
            }
        }
        
        /// <summary>
        /// Create a new report
        /// </summary>
        [HttpPost]
        public async Task<ActionResult<ApiResponse<int>>> CreateReport([FromBody] ReportDefinition report)
        {
            try
            {
                if (!ModelState.IsValid)
                    return BadRequest(ApiResponse<int>.ErrorResult("Invalid model", ModelState.Values.SelectMany(v => v.Errors.Select(e => e.ErrorMessage)).ToList()));
                
                var reportId = await _reportService.CreateReportAsync(report);
                return CreatedAtAction(nameof(GetReportDefinition), new { id = reportId }, ApiResponse<int>.SuccessResult(reportId, "Report created successfully"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating report: {ReportName}", report.ReportName);
                return StatusCode(500, ApiResponse<int>.ErrorResult("Internal server error"));
            }
        }
        
        /// <summary>
        /// Update an existing report
        /// </summary>
        [HttpPut("{id}")]
        public async Task<ActionResult<ApiResponse<bool>>> UpdateReport(int id, [FromBody] ReportDefinition report)
        {
            try
            {
                if (id != report.ReportId)
                    return BadRequest(ApiResponse<bool>.ErrorResult("Report ID mismatch"));
                
                if (!ModelState.IsValid)
                    return BadRequest(ApiResponse<bool>.ErrorResult("Invalid model", ModelState.Values.SelectMany(v => v.Errors.Select(e => e.ErrorMessage)).ToList()));
                
                var success = await _reportService.UpdateReportAsync(report);
                if (!success)
                    return NotFound(ApiResponse<bool>.ErrorResult("Report not found"));
                
                return Ok(ApiResponse<bool>.SuccessResult(true, "Report updated successfully"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating report: {ReportId}", id);
                return StatusCode(500, ApiResponse<bool>.ErrorResult("Internal server error"));
            }
        }
        
        /// <summary>
        /// Delete a report (soft delete)
        /// </summary>
        [HttpDelete("{id}")]
        public async Task<ActionResult<ApiResponse<bool>>> DeleteReport(int id)
        {
            try
            {
                var success = await _reportService.DeleteReportAsync(id);
                if (!success)
                    return NotFound(ApiResponse<bool>.ErrorResult("Report not found"));
                
                return Ok(ApiResponse<bool>.SuccessResult(true, "Report deleted successfully"));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting report: {ReportId}", id);
                return StatusCode(500, ApiResponse<bool>.ErrorResult("Internal server error"));
            }
        }
    }

    public class ReportGenerationRequest
    {
        public Dictionary<string, object> Parameters { get; set; } = new Dictionary<string, object>();
    }
}







import axios from 'axios';

const API_BASE_URL = 'http://localhost:5118/api';

// Configure axios defaults
axios.defaults.timeout = 30000; // 30 seconds timeout

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for logging
api.interceptors.request.use(
  (config) => {
    console.log('API Request:', {
      method: config.method,
      url: config.url,
      data: config.data,
      params: config.params
    });
    return config;
  },
  (error) => {
    console.error('Request Error:', error);
    return Promise.reject(error);
  }
);

// Add response interceptor for logging and error handling
api.interceptors.response.use(
  (response) => {
    console.log('API Response:', {
      url: response.config.url,
      status: response.status,
      data: response.data
    });
    return response;
  },
  (error) => {
    console.error('Response Error:', {
      url: error.config?.url,
      status: error.response?.status,
      message: error.message,
      data: error.response?.data
    });
    return Promise.reject(error);
  }
);

export const reportService = {
  // Get all available reports
  async getAvailableReports() {
    try {
      const response = await api.get('/reports');
      return response.data;
    } catch (error) {
      console.error('Error fetching reports:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to fetch reports',
        data: []
      };
    }
  },

  // Get report definition by ID
  async getReportDefinition(reportId) {
    try {
      const response = await api.get(`/reports/${reportId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching report definition:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to fetch report definition',
        data: null
      };
    }
  },

  // Generate report with parameters
  async generateReport(reportId, parameters = {}) {
    try {
      console.log('Generating report:', { reportId, parameters });
      
      // Ensure parameters is an object and not null/undefined
      const cleanedParameters = parameters || {};
      
      // Remove any null or undefined values
      const filteredParameters = Object.entries(cleanedParameters).reduce((acc, [key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
          acc[key] = value;
        }
        return acc;
      }, {});

      const requestBody = {
        parameters: filteredParameters
      };

      console.log('Request body:', requestBody);

      const response = await api.post(`/reports/${reportId}/generate`, requestBody);
      return response.data;
    } catch (error) {
      console.error('Error generating report:', error);
      
      // Return a more user-friendly error response
      const errorMessage = error.response?.data?.message || 
                          error.response?.data?.errors?.join(', ') || 
                          error.message || 
                          'An unexpected error occurred';
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Create a new report
  async createReport(reportData) {
    try {
      console.log('Creating report with data:', reportData);
      
      // Validate required fields
      if (!reportData.reportName || !reportData.reportName.trim()) {
        return {
          success: false,
          message: 'Report name is required'
        };
      }
      
      if (!reportData.dataSourceType || !reportData.dataSourceType.trim()) {
        return {
          success: false,
          message: 'Data source type is required'
        };
      }
      
      if (!reportData.dataSourceValue || !reportData.dataSourceValue.trim()) {
        return {
          success: false,
          message: 'Data source value is required'
        };
      }

      const response = await api.post('/reports', reportData);
      
      // Check if response has the expected structure
      if (response.data) {
        return response.data; // This should contain { success: true, data: reportId }
      }
      
      return {
        success: true,
        message: 'Report created successfully',
        data: response.data
      };
      
    } catch (error) {
      console.error('Error creating report:', error);
      
      // Extract error message from response
      let errorMessage = 'Failed to create report';
      
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.response?.data?.errors?.length > 0) {
        errorMessage = error.response.data.errors.join(', ');
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Update an existing report
  async updateReport(reportId, reportData) {
    try {
      const response = await api.put(`/reports/${reportId}`, reportData);
      return response.data;
    } catch (error) {
      console.error('Error updating report:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to update report',
        data: null
      };
    }
  },

  // Delete a report
  async deleteReport(reportId) {
    try {
      const response = await api.delete(`/reports/${reportId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting report:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to delete report',
        data: null
      };
    }
  },

  // Export report data
  async exportReport(reportId, parameters = {}, format = 'csv') {
    try {
      const response = await api.post(`/reports/${reportId}/export`, {
        parameters,
        format
      }, {
        responseType: 'blob'
      });
      
      return response.data;
    } catch (error) {
      console.error('Error exporting report:', error);
      throw error;
    }
  }
};


