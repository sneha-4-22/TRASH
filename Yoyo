// Using fetch instead of axios to match your working App.js
const API_BASE_URL = 'http://localhost:5118/api';

export const reportService = {
  // Get all available reports
  async getAvailableReports() {
    try {
      console.log('Fetching reports from:', `${API_BASE_URL}/reports`);
      
      const response = await fetch(`${API_BASE_URL}/reports`);
      console.log('Response status:', response.status, response.statusText);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const responseText = await response.text();
      console.log('Raw response text:', responseText);
      
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      console.log('Parsed response data:', data);
      return data;
    } catch (error) {
      console.error('Error fetching reports:', error);
      return {
        success: false,
        message: error.message || 'Failed to fetch reports',
        data: []
      };
    }
  },

  // Get report definition by ID
  async getReportDefinition(reportId) {
    try {
      console.log('Fetching report definition for ID:', reportId);
      
      const response = await fetch(`${API_BASE_URL}/reports/${reportId}`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const responseText = await response.text();
      console.log('Report definition raw response:', responseText);
      
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      console.log('Report definition data:', data);
      return data;
    } catch (error) {
      console.error('Error fetching report definition:', error);
      return {
        success: false,
        message: error.message || 'Failed to fetch report definition',
        data: null
      };
    }
  },

  // Generate report with parameters
  async generateReport(reportId, parameters = {}) {
    try {
      console.log('Generating report:', { reportId, parameters });
      
      // Ensure parameters is an object and not null/undefined
      const cleanedParameters = parameters || {};
      
      // Remove any null or undefined values
      const filteredParameters = Object.entries(cleanedParameters).reduce((acc, [key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
          acc[key] = value;
        }
        return acc;
      }, {});

      const requestBody = {
        parameters: filteredParameters
      };

      console.log('Request body:', requestBody);

      const response = await fetch(`${API_BASE_URL}/reports/${reportId}/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const responseText = await response.text();
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      return data;
    } catch (error) {
      console.error('Error generating report:', error);
      
      // Return a more user-friendly error response
      return {
        success: false,
        message: error.message || 'An unexpected error occurred',
        data: null
      };
    }
  },

  // Create a new report - FIXED to match your working App.js
  async createReport(reportData) {
    try {
      console.log('Creating report with data:', reportData);
      
      // Validate required fields
      if (!reportData.reportName || !reportData.reportName.trim()) {
        return {
          success: false,
          message: 'Report name is required'
        };
      }
      
      if (!reportData.dataSourceType || !reportData.dataSourceType.trim()) {
        return {
          success: false,
          message: 'Data source type is required'
        };
      }
      
      if (!reportData.dataSourceValue || !reportData.dataSourceValue.trim()) {
        return {
          success: false,
          message: 'Data source value is required'
        };
      }

      // Use fetch instead of axios to match your working App.js
      const response = await fetch(`${API_BASE_URL}/reports`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(reportData)
      });
      
      const responseText = await response.text();
      console.log('Raw response:', responseText);
      
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      if (response.ok && data.success) {
        return data; // Return the success response
      } else {
        console.error('Server error:', data);
        return {
          success: false,
          message: data.message || `Server returned error: ${response.status}`,
          data: null
        };
      }
      
    } catch (error) {
      console.error('Error creating report:', error);
      
      // Extract error message from response
      let errorMessage = 'Failed to create report';
      
      if (error.message) {
        errorMessage = error.message;
      }
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Update an existing report
  async updateReport(reportId, reportData) {
    try {
      const response = await fetch(`${API_BASE_URL}/reports/${reportId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(reportData)
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const responseText = await response.text();
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      return data;
    } catch (error) {
      console.error('Error updating report:', error);
      return {
        success: false,
        message: error.message || 'Failed to update report',
        data: null
      };
    }
  },

  // Delete a report
  async deleteReport(reportId) {
    try {
      const response = await fetch(`${API_BASE_URL}/reports/${reportId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const responseText = await response.text();
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      return data;
    } catch (error) {
      console.error('Error deleting report:', error);
      return {
        success: false,
        message: error.message || 'Failed to delete report',
        data: null
      };
    }
  },

  // Export report data
  async exportReport(reportId, parameters = {}, format = 'csv') {
    try {
      const response = await fetch(`${API_BASE_URL}/reports/${reportId}/export`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          parameters,
          format
        })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.blob();
    } catch (error) {
      console.error('Error exporting report:', error);
      throw error;
    }
  }
};
import React, { useState } from 'react';
import { reportService } from '../services/reportService';
import '../styles/ReportForm.css';

const ReportForm = ({ onBack, onSave }) => {
  const [formData, setFormData] = useState({
    reportName: '',
    description: '',
    category: '',
    dataSourceType: 'SQL',
    dataSourceValue: '',
    accessRoles: '',
    isActive: true
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log('Form submitted with data:', formData);
    
    // Validate required fields
    if (!formData.reportName.trim()) {
      setError('Report Name is required');
      return;
    }
    if (!formData.dataSourceValue.trim()) {
      setError('Data Source Value is required');
      return;
    }
    
    try {
      setLoading(true);
      setError(null);
      
      // Format access roles exactly like App.js
      let accessRolesFormatted = '["Admin"]'; // Default fallback
      if (formData.accessRoles && formData.accessRoles.trim()) {
        const rolesArray = formData.accessRoles
          .split(',')
          .map(role => role.trim())
          .filter(role => role.length > 0);
        if (rolesArray.length > 0) {
          accessRolesFormatted = `["${rolesArray.join('","')}"]`;
        }
      }
      
      // Match the EXACT structure that works in App.js
      const reportData = {
        reportName: formData.reportName.trim(),
        description: formData.description?.trim() || null,  // null instead of ''
        category: formData.category?.trim() || null,        // null instead of ''
        dataSourceType: formData.dataSourceType,
        dataSourceValue: formData.dataSourceValue.trim(),
        parameters: "",       // ← ADD THIS (required field)
        layoutSettings: "",   // ← ADD THIS (required field)
        accessRoles: accessRolesFormatted,
        isActive: formData.isActive
      };
      
      console.log('Final report data being sent:', reportData);
      console.log('AccessRoles formatted as:', accessRolesFormatted);
      
      const response = await reportService.createReport(reportData);
      console.log('Response received:', response);
      
      if (response && response.success) {
        console.log('Report created successfully!');
        setSuccess(true);
        setTimeout(() => {
          if (onSave) onSave();
        }, 2000);
      } else {
        console.error('Report creation failed:', response);
        setError(response?.message || 'Failed to create report');
      }
    } catch (err) {
      console.error('Exception in handleSubmit:', err);
      console.error('Error response:', err.response);
      
      // Better error handling
      let errorMessage = 'Failed to create report';
      if (err.response?.data?.message) {
        errorMessage = err.response.data.message;
      } else if (err.response?.data?.errors) {
        errorMessage = Array.isArray(err.response.data.errors) 
          ? err.response.data.errors.join(', ') 
          : err.response.data.errors;
      } else if (err.message) {
        errorMessage = err.message;
      }
      
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="success-message">
        <h2>✅ Report Created Successfully!</h2>
        <p>Redirecting back to reports list...</p>
      </div>
    );
  }

  return (
    <div className="report-form">
      <div className="form-header">
        <button 
          className="btn btn-secondary" 
          onClick={onBack}
          type="button"
        >
          ← Back to Reports
        </button>
        <h2>Create New Report</h2>
      </div>

      <form onSubmit={handleSubmit} className="form">
        <div className="form-group">
          <label htmlFor="reportName">Report Name *</label>
          <input
            type="text"
            id="reportName"
            name="reportName"
            value={formData.reportName}
            onChange={handleInputChange}
            required
            className="form-input"
            maxLength="100"
          />
        </div>

        <div className="form-group">
          <label htmlFor="description">Description</label>
          <textarea
            id="description"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            rows="3"
            className="form-textarea"
            maxLength="500"
          />
        </div>

        <div className="form-row">
          <div className="form-group">
            <label htmlFor="category">Category</label>
            <input
              type="text"
              id="category"
              name="category"
              value={formData.category}
              onChange={handleInputChange}
              className="form-input"
              maxLength="50"
            />
          </div>

          <div className="form-group">
            <label htmlFor="dataSourceType">Data Source Type *</label>
            <select
              id="dataSourceType"
              name="dataSourceType"
              value={formData.dataSourceType}
              onChange={handleInputChange}
              required
              className="form-select"
            >
              <option value="SQL">SQL Query</option>
              <option value="StoredProcedure">Stored Procedure</option>
              <option value="API">API Endpoint</option>
            </select>
          </div>
        </div>

        <div className="form-group">
          <label htmlFor="dataSourceValue">
            {formData.dataSourceType === 'StoredProcedure' ? 'Procedure Name' : 
             formData.dataSourceType === 'API' ? 'API Endpoint' : 'SQL Query'} *
          </label>
          <textarea
            id="dataSourceValue"
            name="dataSourceValue"
            value={formData.dataSourceValue}
            onChange={handleInputChange}
            required
            rows="4"
            className="form-textarea"
            placeholder={
              formData.dataSourceType === 'StoredProcedure' ? 'GetEmployeeReport' :
              formData.dataSourceType === 'API' ? 'https://api.example.com/data' :
              'SELECT * FROM TableName WHERE Column = @Parameter'
            }
          />
        </div>

        <div className="form-group">
          <label htmlFor="accessRoles">Access Roles (comma separated)</label>
          <input
            type="text"
            id="accessRoles"
            name="accessRoles"
            value={formData.accessRoles}
            onChange={handleInputChange}
            className="form-input"
            placeholder="Admin, HR, Sales"
          />
          <small className="form-help">Enter roles separated by commas (e.g., Admin, HR, Sales)</small>
        </div>

        <div className="form-group">
          <label className="checkbox-label">
            <input
              type="checkbox"
              name="isActive"
              checked={formData.isActive}
              onChange={handleInputChange}
            />
            Active
          </label>
        </div>

        {error && (
          <div className="error-message">
            <strong>Error:</strong> {error}
          </div>
        )}

        <div className="form-actions">
          <button 
            type="button" 
            className="btn btn-secondary" 
            onClick={onBack}
          >
            Cancel
          </button>
          <button 
            type="submit" 
            className="btn btn-primary" 
            disabled={loading}
          >
            {loading ? 'Creating...' : 'Create Report'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default ReportForm;
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5118/api';

// Configure axios defaults
axios.defaults.timeout = 30000; // 30 seconds timeout

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for logging
api.interceptors.request.use(
  (config) => {
    console.log('API Request:', {
      method: config.method,
      url: config.url,
      data: config.data,
      params: config.params
    });
    return config;
  },
  (error) => {
    console.error('Request Error:', error);
    return Promise.reject(error);
  }
);

// Add response interceptor for logging and error handling
api.interceptors.response.use(
  (response) => {
    console.log('API Response:', {
      url: response.config.url,
      status: response.status,
      data: response.data
    });
    return response;
  },
  (error) => {
    console.error('Response Error:', {
      url: error.config?.url,
      status: error.response?.status,
      message: error.message,
      data: error.response?.data
    });
    return Promise.reject(error);
  }
);

export const reportService = {
  // Get all available reports
  async getAvailableReports() {
    try {
      const response = await api.get('/reports');
      return response.data;
    } catch (error) {
      console.error('Error fetching reports:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to fetch reports',
        data: []
      };
    }
  },

  // Get report definition by ID
  async getReportDefinition(reportId) {
    try {
      const response = await api.get(`/reports/${reportId}`);
      return response.data;
    } catch (error) {
      console.error('Error fetching report definition:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to fetch report definition',
        data: null
      };
    }
  },

  // Generate report with parameters
  async generateReport(reportId, parameters = {}) {
    try {
      console.log('Generating report:', { reportId, parameters });
      
      // Ensure parameters is an object and not null/undefined
      const cleanedParameters = parameters || {};
      
      // Remove any null or undefined values
      const filteredParameters = Object.entries(cleanedParameters).reduce((acc, [key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
          acc[key] = value;
        }
        return acc;
      }, {});

      const requestBody = {
        parameters: filteredParameters
      };

      console.log('Request body:', requestBody);

      const response = await api.post(`/reports/${reportId}/generate`, requestBody);
      return response.data;
    } catch (error) {
      console.error('Error generating report:', error);
      
      // Return a more user-friendly error response
      const errorMessage = error.response?.data?.message || 
                          error.response?.data?.errors?.join(', ') || 
                          error.message || 
                          'An unexpected error occurred';
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Create a new report
  async createReport(reportData) {
    try {
      console.log('Creating report with data:', reportData);
      
      // Validate required fields
      if (!reportData.reportName || !reportData.reportName.trim()) {
        return {
          success: false,
          message: 'Report name is required'
        };
      }
      
      if (!reportData.dataSourceType || !reportData.dataSourceType.trim()) {
        return {
          success: false,
          message: 'Data source type is required'
        };
      }
      
      if (!reportData.dataSourceValue || !reportData.dataSourceValue.trim()) {
        return {
          success: false,
          message: 'Data source value is required'
        };
      }

      const response = await api.post('/reports', reportData);
      
      // Check if response has the expected structure
      if (response.data) {
        return response.data; // This should contain { success: true, data: reportId }
      }
      
      return {
        success: true,
        message: 'Report created successfully',
        data: response.data
      };
      
    } catch (error) {
      console.error('Error creating report:', error);
      
      // Extract error message from response
      let errorMessage = 'Failed to create report';
      
      if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.response?.data?.errors?.length > 0) {
        errorMessage = error.response.data.errors.join(', ');
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      return {
        success: false,
        message: errorMessage,
        data: null
      };
    }
  },

  // Update an existing report
  async updateReport(reportId, reportData) {
    try {
      const response = await api.put(`/reports/${reportId}`, reportData);
      return response.data;
    } catch (error) {
      console.error('Error updating report:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to update report',
        data: null
      };
    }
  },

  // Delete a report
  async deleteReport(reportId) {
    try {
      const response = await api.delete(`/reports/${reportId}`);
      return response.data;
    } catch (error) {
      console.error('Error deleting report:', error);
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to delete report',
        data: null
      };
    }
  },

  // Export report data
  async exportReport(reportId, parameters = {}, format = 'csv') {
    try {
      const response = await api.post(`/reports/${reportId}/export`, {
        parameters,
        format
      }, {
        responseType: 'blob'
      });
      
      return response.data;
    } catch (error) {
      console.error('Error exporting report:', error);
      throw error;
    }
  }
};
import React, { useState } from 'react';
import { reportService } from '../services/reportService';
import '../styles/ReportForm.css';

const ReportForm = ({ onBack, onSave }) => {
  const [formData, setFormData] = useState({
    reportName: '',
    description: '',
    category: '',
    dataSourceType: 'SQL',
    dataSourceValue: '',
    accessRoles: '',
    isActive: true
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log('Form submitted with data:', formData);
    
    try {
      setLoading(true);
      setError(null);
      
      // Exactly match your backend working format
      let accessRolesFormatted = '[]';
      if (formData.accessRoles && formData.accessRoles.trim()) {
        const rolesArray = formData.accessRoles
          .split(',')
          .map(role => role.trim())
          .filter(role => role.length > 0);
        accessRolesFormatted = `["${rolesArray.join('","')}"]`;
      }
      
      const reportData = {
        reportName: formData.reportName.trim(),
        description: formData.description?.trim() || '',
        category: formData.category?.trim() || '',
        dataSourceType: formData.dataSourceType,
        dataSourceValue: formData.dataSourceValue.trim(),
        accessRoles: accessRolesFormatted,
        isActive: formData.isActive
      };
      
      console.log('Final report data being sent:', reportData);
      console.log('AccessRoles formatted as:', accessRolesFormatted);
      
      const response = await reportService.createReport(reportData);
      console.log('Response received:', response);
      
      if (response && response.success) {
        console.log('Report created successfully!');
        setSuccess(true);
        setTimeout(() => {
          onSave();
        }, 2000);
      } else {
        console.error('Report creation failed:', response);
        setError(response?.message || 'Failed to create report');
      }
    } catch (err) {
      console.error('Exception in handleSubmit:', err);
      console.error('Error response:', err.response);
      setError(err.response?.data?.message || err.message || 'Failed to create report');
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="success-message">
        <h2>✅ Report Created Successfully!</h2>
        <p>Redirecting back to reports list...</p>
      </div>
    );
  }

  return (
    <div className="report-form">
      <div className="form-header">
        <button className="btn btn-secondary" onClick={onBack}>
          ← Back to Reports
        </button>
        <h2>Create New Report</h2>
      </div>

      <form onSubmit={handleSubmit} className="form">
        <div className="form-group">
          <label htmlFor="reportName">Report Name *</label>
          <input
            type="text"
            id="reportName"
            name="reportName"
            value={formData.reportName}
            onChange={handleInputChange}
            required
            className="form-input"
            maxLength="100"
          />
        </div>

        <div className="form-group">
          <label htmlFor="description">Description</label>
          <textarea
            id="description"
            name="description"
            value={formData.description}
            onChange={handleInputChange}
            rows="3"
            className="form-textarea"
            maxLength="500"
          />
        </div>

        <div className="form-row">
          <div className="form-group">
            <label htmlFor="category">Category</label>
            <input
              type="text"
              id="category"
              name="category"
              value={formData.category}
              onChange={handleInputChange}
              className="form-input"
              maxLength="50"
            />
          </div>

          <div className="form-group">
            <label htmlFor="dataSourceType">Data Source Type *</label>
            <select
              id="dataSourceType"
              name="dataSourceType"
              value={formData.dataSourceType}
              onChange={handleInputChange}
              required
              className="form-select"
            >
              <option value="SQL">SQL Query</option>
              <option value="StoredProcedure">Stored Procedure</option>
              <option value="API">API Endpoint</option>
            </select>
          </div>
        </div>

        <div className="form-group">
          <label htmlFor="dataSourceValue">
            {formData.dataSourceType === 'StoredProcedure' ? 'Procedure Name' : 
             formData.dataSourceType === 'API' ? 'API Endpoint' : 'SQL Query'} *
          </label>
          <textarea
            id="dataSourceValue"
            name="dataSourceValue"
            value={formData.dataSourceValue}
            onChange={handleInputChange}
            required
            rows="4"
            className="form-textarea"
            placeholder={
              formData.dataSourceType === 'StoredProcedure' ? 'GetEmployeeReport' :
              formData.dataSourceType === 'API' ? 'https://api.example.com/data' :
              'SELECT * FROM TableName WHERE Column = @Parameter'
            }
          />
        </div>

        <div className="form-group">
          <label htmlFor="accessRoles">Access Roles (comma separated)</label>
          <input
            type="text"
            id="accessRoles"
            name="accessRoles"
            value={formData.accessRoles}
            onChange={handleInputChange}
            className="form-input"
            placeholder="Admin, HR, Sales"
          />
          <small className="form-help">Enter roles separated by commas (e.g., Admin, HR, Sales)</small>
        </div>

        <div className="form-group">
          <label className="checkbox-label">
            <input
              type="checkbox"
              name="isActive"
              checked={formData.isActive}
              onChange={handleInputChange}
            />
            Active
          </label>
        </div>

        {error && (
          <div className="error-message">
            <strong>Error:</strong> {error}
          </div>
        )}

        <div className="form-actions">
          <button type="button" className="btn btn-secondary" onClick={onBack}>
            Cancel
          </button>
          <button type="submit" className="btn btn-primary" disabled={loading}>
            {loading ? 'Creating...' : 'Create Report'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default ReportForm;

import React, { useState, useEffect } from 'react';
import './App.css';

const API_BASE = 'http://localhost:5118/api';

const App = () => {
  const [activeTab, setActiveTab] = useState('reports');
  const [reports, setReports] = useState([]);
  const [selectedReport, setSelectedReport] = useState(null);
  const [reportData, setReportData] = useState(null);
  const [parameters, setParameters] = useState({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // New Report Form State
  const [newReport, setNewReport] = useState({
    reportName: '',
    description: '',
    category: '',
    dataSourceType: 'SQL',
    dataSourceValue: '',
    accessRoles: '["Admin"]'
  });

  useEffect(() => {
    fetchReports();
  }, []);

  const fetchReports = async () => {
    try {
      setLoading(true);
      setError('');
      const response = await fetch(`${API_BASE}/reports`);
      const data = await response.json();
      console.log('Fetch reports response:', data);
      if (data.success) {
        setReports(data.data);
      } else {
        setError(data.message || 'Failed to fetch reports');
      }
    } catch (err) {
      console.error('Fetch reports error:', err);
      setError('Failed to fetch reports: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  const fetchReportDefinition = async (reportId) => {
    try {
      setLoading(true);
      const response = await fetch(`${API_BASE}/reports/${reportId}`);
      const data = await response.json();
      if (data.success) {
        setSelectedReport(data.data);
        // Initialize parameters with default values
        const initialParams = {};
        data.data.reportParameters.forEach(param => {
          if (param.defaultValue) {
            initialParams[param.parameterName] = param.defaultValue;
          }
        });
        setParameters(initialParams);
      } else {
        setError(data.message);
      }
    } catch (err) {
      setError('Failed to fetch report definition');
    } finally {
      setLoading(false);
    }
  };

  const generateReport = async () => {
    if (!selectedReport) return;
    
    try {
      setLoading(true);
      setError('');
      const response = await fetch(`${API_BASE}/reports/${selectedReport.reportId}/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ parameters })
      });
      
      const data = await response.json();
      if (data.success) {
        setReportData(data.data);
        setSuccess('Report generated successfully');
      } else {
        setError(data.message);
      }
    } catch (err) {
      setError('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  const createReport = async () => {
    try {
      setLoading(true);
      setError('');
      
      // Validate required fields
      if (!newReport.reportName.trim()) {
        setError('Report Name is required');
        return;
      }
      if (!newReport.dataSourceValue.trim()) {
        setError('Data Source Value is required');
        return;
      }
      
      // Match your exact ReportDefinition model structure
      const reportPayload = {
        reportName: newReport.reportName.trim(),
        description: newReport.description.trim() || null,
        category: newReport.category.trim() || null,
        dataSourceType: newReport.dataSourceType,
        dataSourceValue: newReport.dataSourceValue.trim(),
        parameters: "", // Empty string instead of null since it's required
        layoutSettings: "", // Empty string instead of null since it's required
        accessRoles: newReport.accessRoles,
        isActive: true
      };
      
      console.log('Sending report payload:', reportPayload);
      
      const response = await fetch(`${API_BASE}/reports`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(reportPayload)
      });
      
      const responseText = await response.text();
      console.log('Raw response:', responseText);
      
      let data;
      try {
        data = JSON.parse(responseText);
      } catch (e) {
        throw new Error(`Invalid JSON response: ${responseText}`);
      }
      
      if (response.ok && data.success) {
        setSuccess('Report created successfully');
        setNewReport({
          reportName: '',
          description: '',
          category: '',
          dataSourceType: 'SQL',
          dataSourceValue: '',
          accessRoles: '["Admin"]'
        });
        fetchReports();
      } else {
        console.error('Server error:', data);
        setError(data.message || `Server returned error: ${response.status}`);
        if (data.errors && data.errors.length > 0) {
          setError(data.errors.join(', '));
        }
      }
    } catch (err) {
      console.error('Create report error:', err);
      setError('Failed to create report: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  const handleParameterChange = (paramName, value) => {
    setParameters(prev => ({
      ...prev,
      [paramName]: value
    }));
  };

  const exportToCSV = () => {
    if (!reportData || !reportData.rows) return;
    
    const csvContent = [
      reportData.columns.map(col => col.name).join(','),
      ...reportData.rows.map(row => 
        reportData.columns.map(col => {
          const value = row[col.name];
          return value ? `"${value}"` : '';
        }).join(',')
      )
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${selectedReport?.reportName || 'report'}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const renderParameterInput = (param) => {
    switch (param.parameterType.toLowerCase()) {
      case 'text':
      case 'string':
        return (
          <input
            type="text"
            value={parameters[param.parameterName] || ''}
            onChange={(e) => handleParameterChange(param.parameterName, e.target.value)}
            placeholder={param.defaultValue}
            required={param.isRequired}
          />
        );
      case 'number':
      case 'int':
        return (
          <input
            type="number"
            value={parameters[param.parameterName] || ''}
            onChange={(e) => handleParameterChange(param.parameterName, e.target.value)}
            placeholder={param.defaultValue}
            required={param.isRequired}
          />
        );
      case 'date':
      case 'datetime':
        return (
          <input
            type="date"
            value={parameters[param.parameterName] || ''}
            onChange={(e) => handleParameterChange(param.parameterName, e.target.value)}
            required={param.isRequired}
          />
        );
      case 'dropdown':
        const options = param.dropdownOptionsList || [];
        return (
          <select
            value={parameters[param.parameterName] || ''}
            onChange={(e) => handleParameterChange(param.parameterName, e.target.value)}
            required={param.isRequired}
          >
            <option value="">Select...</option>
            {options.map(opt => (
              <option key={opt.value} value={opt.value}>{opt.display}</option>
            ))}
          </select>
        );
      default:
        return (
          <input
            type="text"
            value={parameters[param.parameterName] || ''}
            onChange={(e) => handleParameterChange(param.parameterName, e.target.value)}
            placeholder={param.defaultValue}
            required={param.isRequired}
          />
        );
    }
  };

  return (
    <div className="app">
      <div className="header">
        <h1>Dynamic Report Builder</h1>
        <div className="tabs">
          <button 
            className={activeTab === 'reports' ? 'active' : ''} 
            onClick={() => setActiveTab('reports')}
          >
            Reports
          </button>
          <button 
            className={activeTab === 'create' ? 'active' : ''} 
            onClick={() => setActiveTab('create')}
          >
            Create Report
          </button>
        </div>
      </div>

      {error && (
        <div className="alert error">
          <span>{error}</span>
          <button onClick={() => setError('')}>×</button>
        </div>
      )}

      {success && (
        <div className="alert success">
          <span>{success}</span>
          <button onClick={() => setSuccess('')}>×</button>
        </div>
      )}

      <div className="content">
        {activeTab === 'reports' && (
          <div className="reports-section">
            <div className="sidebar">
              <h3>Available Reports</h3>
              {loading && <div className="loading">Loading reports...</div>}
              <div className="reports-list">
                {reports.map(report => (
                  <div 
                    key={report.reportId} 
                    className={`report-item ${selectedReport?.reportId === report.reportId ? 'selected' : ''}`}
                    onClick={() => fetchReportDefinition(report.reportId)}
                  >
                    <h4>{report.reportName}</h4>
                    <p>{report.description}</p>
                    <small>Category: {report.category}</small>
                  </div>
                ))}
              </div>
            </div>

            <div className="main-content">
              {selectedReport ? (
                <div>
                  <div className="report-header">
                    <h2>{selectedReport.reportName}</h2>
                    <p>{selectedReport.description}</p>
                  </div>

                  {selectedReport.reportParameters && selectedReport.reportParameters.length > 0 && (
                    <div className="parameters-section">
                      <h3>Parameters</h3>
                      <div className="parameters-form">
                        {selectedReport.reportParameters.map(param => (
                          <div key={param.parameterId} className="parameter-group">
                            <label>
                              {param.displayName}
                              {param.isRequired && <span className="required">*</span>}
                            </label>
                            {renderParameterInput(param)}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  <div className="actions">
                    <button 
                      className="btn primary" 
                      onClick={generateReport}
                      disabled={loading}
                    >
                      {loading ? 'Generating...' : 'Generate Report'}
                    </button>
                    {reportData && (
                      <button className="btn secondary" onClick={exportToCSV}>
                        Export to CSV
                      </button>
                    )}
                  </div>

                  {reportData && (
                    <div className="report-results">
                      <h3>Report Results ({Array.isArray(reportData.rows) ? reportData.rows.length : 0} rows)</h3>
                      <div className="table-container">
                        <table>
                          <thead>
                            <tr>
                              {reportData.columns?.map(col => (
                                <th key={col.name}>{col.name}</th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {Array.isArray(reportData.rows) && reportData.rows.map((row, index) => (
                              <tr key={index}>
                                {reportData.columns?.map(col => (
                                  <td key={col.name}>
                                    {row[col.name] !== null && row[col.name] !== undefined 
                                      ? String(row[col.name]) 
                                      : ''}
                                  </td>
                                ))}
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <div className="no-selection">
                  <h3>Select a report to view details</h3>
                  <p>Choose a report from the list on the left to view its parameters and generate data.</p>
                </div>
              )}
            </div>
          </div>
        )}

        {activeTab === 'create' && (
          <div className="create-section">
            <h2>Create New Report</h2>
            <div className="create-form">
              <div className="form-group">
                <label>Report Name *</label>
                <input
                  type="text"
                  value={newReport.reportName}
                  onChange={(e) => setNewReport({...newReport, reportName: e.target.value})}
                  required
                />
              </div>

              <div className="form-group">
                <label>Description</label>
                <textarea
                  value={newReport.description}
                  onChange={(e) => setNewReport({...newReport, description: e.target.value})}
                  rows="3"
                />
              </div>

              <div className="form-group">
                <label>Category</label>
                <input
                  type="text"
                  value={newReport.category}
                  onChange={(e) => setNewReport({...newReport, category: e.target.value})}
                />
              </div>

              <div className="form-group">
                <label>Data Source Type *</label>
                <select
                  value={newReport.dataSourceType}
                  onChange={(e) => setNewReport({...newReport, dataSourceType: e.target.value})}
                  required
                >
                  <option value="SQL">SQL Query</option>
                  <option value="StoredProcedure">Stored Procedure</option>
                </select>
              </div>

              <div className="form-group">
                <label>Data Source Value *</label>
                <textarea
                  value={newReport.dataSourceValue}
                  onChange={(e) => setNewReport({...newReport, dataSourceValue: e.target.value})}
                  rows="6"
                  placeholder="Enter SQL query or stored procedure name"
                  required
                />
              </div>

              <div className="form-group">
                <label>Access Roles (JSON format)</label>
                <input
                  type="text"
                  value={newReport.accessRoles}
                  onChange={(e) => setNewReport({...newReport, accessRoles: e.target.value})}
                  placeholder='["Admin", "HR"]'
                />
              </div>

              <div className="form-actions">
                <button type="button" className="btn primary" disabled={loading} onClick={createReport}>
                  {loading ? 'Creating...' : 'Create Report'}
                </button>
                <button type="button" className="btn secondary" onClick={() => {
                  setNewReport({
                    reportName: '',
                    description: '',
                    category: '',
                    dataSourceType: 'SQL',
                    dataSourceValue: '',
                    accessRoles: '["Admin"]'
                  });
                }}>
                  Clear Form
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};


// Add CSS styles
const styles = `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f5f5f5;
  color: #333;
}

.app {
  min-height: 100vh;
}

.header {
  background: white;
  border-bottom: 1px solid #ddd;
  padding: 1rem 2rem;
}

.header h1 {
  margin-bottom: 1rem;
  color: #2c3e50;
}

.tabs {
  display: flex;
  gap: 1rem;
}

.tabs button {
  padding: 0.5rem 1rem;
  border: 1px solid #ddd;
  background: #f8f9fa;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s;
}

.tabs button:hover {
  background: #e9ecef;
}

.tabs button.active {
  background: #007bff;
  color: white;
  border-color: #007bff;
}

.alert {
  padding: 0.75rem 1rem;
  margin: 1rem 2rem;
  border-radius: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.alert.error {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.alert.success {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.alert button {
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.content {
  padding: 2rem;
}

.reports-section {
  display: flex;
  gap: 2rem;
  height: calc(100vh - 200px);
}

.sidebar {
  flex: 0 0 300px;
  background: white;
  border-radius: 8px;
  padding: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  overflow-y: auto;
}

.sidebar h3 {
  margin-bottom: 1rem;
  color: #2c3e50;
}

.reports-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.report-item {
  padding: 1rem;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

.report-item:hover {
  background: #f8f9fa;
  border-color: #007bff;
}

.report-item.selected {
  background: #e7f3ff;
  border-color: #007bff;
}

.report-item h4 {
  margin-bottom: 0.5rem;
  color: #2c3e50;
}

.report-item p {
  color: #6c757d;
  font-size: 0.9rem;
  margin-bottom: 0.5rem;
}

.report-item small {
  color: #868e96;
}

.main-content {
  flex: 1;
  background: white;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  overflow-y: auto;
}

.report-header {
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e9ecef;
}

.report-header h2 {
  color: #2c3e50;
  margin-bottom: 0.5rem;
}

.parameters-section {
  margin-bottom: 2rem;
}

.parameters-section h3 {
  margin-bottom: 1rem;
  color: #2c3e50;
}

.parameters-form {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}

.parameter-group {
  display: flex;
  flex-direction: column;
}

.parameter-group label {
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #495057;
}

.required {
  color: #dc3545;
  margin-left: 0.25rem;
}

.parameter-group input,
.parameter-group select {
  padding: 0.5rem;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 0.9rem;
}

.parameter-group input:focus,
.parameter-group select:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.actions {
  margin: 2rem 0;
  display: flex;
  gap: 1rem;
}

.btn {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.2s;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn.primary {
  background: #007bff;
  color: white;
}

.btn.primary:hover:not(:disabled) {
  background: #0056b3;
}

.btn.secondary {
  background: #6c757d;
  color: white;
}

.btn.secondary:hover:not(:disabled) {
  background: #545b62;
}

.report-results {
  margin-top: 2rem;
}

.report-results h3 {
  margin-bottom: 1rem;
  color: #2c3e50;
}

.table-container {
  max-height: 400px;
  overflow: auto;
  border: 1px solid #dee2e6;
  border-radius: 4px;
}

table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  padding: 0.75rem;
  text-align: left;
  border-bottom: 1px solid #dee2e6;
}

th {
  background: #f8f9fa;
  font-weight: 600;
  position: sticky;
  top: 0;
  z-index: 1;
}

tbody tr:hover {
  background: #f8f9fa;
}

.no-selection {
  text-align: center;
  color: #6c757d;
  margin-top: 4rem;
}

.create-section {
  max-width: 800px;
  margin: 0 auto;
  background: white;
  border-radius: 8px;
  padding: 2rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.create-section h2 {
  margin-bottom: 2rem;
  color: #2c3e50;
}

.create-form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.form-group {
  display: flex;
  flex-direction: column;
}

.form-group label {
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #495057;
}

.form-group input,
.form-group select,
.form-group textarea {
  padding: 0.75rem;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 0.9rem;
  font-family: inherit;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.form-group textarea {
  resize: vertical;
  font-family: 'Courier New', monospace;
}
  `;
if(typeof document!='undefined'){
  const styleSheet=document.createElement('style');
  styleSheet.textContent=styles;
  document.head.appendChild(styleSheet);
}
export default App;
